The network protocol between server and client uses both "messages" and 
"commands."

--------
Messages
--------
"Messages" are from server to client; clients send only commands to the
server, not messages.  Messages are generally some sort of low-level
state update.  (e.g. something moved or died.)

Therefore, in a server controller context, you would create a message
like so:

Packet p = new Packet(msg_create_unit);
	p->putInt(somePlayerId);	// the owner of the unit
	p->putInt(someUnitId);		// the unit's id
	p->putFloat(unitX);			// the unit's location
	p->putFloat(unitY);
network->sendToAll(p);

The client will deconstruct the message in the switch in:
ClientController::processMessages().  Deconstruction is the exact opposite
of packet assembly, except that once you are in that switch statement, 
the enumeration value has already been extracted as an integer.  So, 
you just extract all of the remaining fields.  For example:

case msg_create_unit: {
	playerID playerId = packet->getInt();
	unitID unitId     = packet->getInt();
	float x           = packet->getFloat();
	float y           = packet->getFloat();
	
	//...do some stuff with the data you extracted...
	}

	-------------------
	Adding new Messages
	-------------------
	If you want to add a new message type, then add a new entry
	into the enumeration in protocol.hpp.  Give it a description, as well as 
	some comments describing the data that will be sent in a packet.
	
	Make sure that you include the enumeration itself as the very
	first thing when you assemble the packet!

--------
Commands
--------
"Commands" can be generated by the server or the client.  When the server
generates a command, that means the host told one of his units to do 
something.  It will modify the host's own local state, and it will also
be converted into a message that will be sent over the network.

When the client generates a command, it does not use that command to update
its own state directly.  Rather, it sends the command to the server.  The 
server will then update its own state, and send the resulting state update
over the network.

We won't have to worry much about client->server transactions, because there 
are very few commands that the server needs to understand, and all commands
follow the exact same structure.

All we have to do is fill out the switch statement in 
ServerController::processCommands(), and then the game will understand 
commands coming from either servers or clients.